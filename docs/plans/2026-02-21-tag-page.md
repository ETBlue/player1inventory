# Tag Detail Page Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add tag detail page with Info and Items tabs, mirroring vendor detail page pattern

**Architecture:** Tabbed layout with dirty state tracking via TagLayoutProvider, Info tab for editing tag name, Items tab for managing item assignments with immediate saves

**Tech Stack:** React 19, TanStack Router, TanStack Query, Vitest, React Testing Library

---

## Task 1: Create useTagLayout hook

**Files:**
- Create: `src/hooks/useTagLayout.tsx`
- Reference: `src/hooks/useVendorLayout.tsx` (mirror this pattern)

**Step 1: Write the failing test**

Create `src/hooks/useTagLayout.test.tsx`:

```tsx
import { renderHook, act } from '@testing-library/react'
import { describe, it, expect } from 'vitest'
import { TagLayoutProvider, useTagLayout } from './useTagLayout'

describe('useTagLayout', () => {
  it('throws error when used outside provider', () => {
    expect(() => {
      renderHook(() => useTagLayout())
    }).toThrow('useTagLayout must be used within TagLayoutProvider')
  })

  it('provides isDirty state and registerDirtyState function', () => {
    const wrapper = ({ children }: { children: React.ReactNode }) => (
      <TagLayoutProvider>{children}</TagLayoutProvider>
    )

    const { result } = renderHook(() => useTagLayout(), { wrapper })

    expect(result.current.isDirty).toBe(false)
    expect(typeof result.current.registerDirtyState).toBe('function')
  })

  it('updates isDirty when registerDirtyState is called', () => {
    const wrapper = ({ children }: { children: React.ReactNode }) => (
      <TagLayoutProvider>{children}</TagLayoutProvider>
    )

    const { result } = renderHook(() => useTagLayout(), { wrapper })

    act(() => {
      result.current.registerDirtyState(true)
    })

    expect(result.current.isDirty).toBe(true)

    act(() => {
      result.current.registerDirtyState(false)
    })

    expect(result.current.isDirty).toBe(false)
  })
})
```

**Step 2: Run test to verify it fails**

```bash
pnpm test src/hooks/useTagLayout.test.tsx
```

Expected: FAIL - module not found

**Step 3: Write minimal implementation**

Create `src/hooks/useTagLayout.tsx`:

```tsx
import { createContext, useCallback, useContext, useState } from 'react'

interface TagLayoutContextValue {
  isDirty: boolean
  registerDirtyState: (dirty: boolean) => void
}

const TagLayoutContext = createContext<TagLayoutContextValue | null>(null)

export function TagLayoutProvider({
  children,
}: {
  children: React.ReactNode
}) {
  const [isDirty, setIsDirty] = useState(false)

  const registerDirtyState = useCallback((dirty: boolean) => {
    setIsDirty(dirty)
  }, [])

  return (
    <TagLayoutContext.Provider value={{ isDirty, registerDirtyState }}>
      {children}
    </TagLayoutContext.Provider>
  )
}

export function useTagLayout() {
  const context = useContext(TagLayoutContext)
  if (!context) {
    throw new Error('useTagLayout must be used within TagLayoutProvider')
  }
  return context
}
```

**Step 4: Run test to verify it passes**

```bash
pnpm test src/hooks/useTagLayout.test.tsx
```

Expected: PASS (all 3 tests)

**Step 5: Commit**

```bash
git add src/hooks/useTagLayout.tsx src/hooks/useTagLayout.test.tsx
git commit -m "feat(tags): add useTagLayout hook for dirty state tracking"
```

---

## Task 2: Create TagNameForm component

**Files:**
- Create: `src/components/TagNameForm.tsx`
- Reference: `src/components/VendorNameForm.tsx` (mirror this pattern)

**Step 1: Write the failing test**

Create `src/components/TagNameForm.test.tsx`:

```tsx
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { describe, it, expect, vi } from 'vitest'
import { TagNameForm } from './TagNameForm'

describe('TagNameForm', () => {
  it('renders name input with value', () => {
    render(
      <TagNameForm
        name="Dairy"
        onNameChange={vi.fn()}
        onSave={vi.fn()}
        isDirty={false}
      />
    )

    const input = screen.getByLabelText('Name')
    expect(input).toHaveValue('Dairy')
  })

  it('calls onNameChange when input changes', async () => {
    const user = userEvent.setup()
    const onNameChange = vi.fn()

    render(
      <TagNameForm
        name="Dairy"
        onNameChange={onNameChange}
        onSave={vi.fn()}
        isDirty={false}
      />
    )

    const input = screen.getByLabelText('Name')
    await user.clear(input)
    await user.type(input, 'Meat')

    expect(onNameChange).toHaveBeenCalledWith('Meat')
  })

  it('disables save button when not dirty', () => {
    render(
      <TagNameForm
        name="Dairy"
        onNameChange={vi.fn()}
        onSave={vi.fn()}
        isDirty={false}
      />
    )

    const saveButton = screen.getByRole('button', { name: /save/i })
    expect(saveButton).toBeDisabled()
  })

  it('enables save button when dirty', () => {
    render(
      <TagNameForm
        name="Dairy"
        onNameChange={vi.fn()}
        onSave={vi.fn()}
        isDirty={true}
      />
    )

    const saveButton = screen.getByRole('button', { name: /save/i })
    expect(saveButton).not.toBeDisabled()
  })

  it('calls onSave when form is submitted', async () => {
    const user = userEvent.setup()
    const onSave = vi.fn()

    render(
      <TagNameForm
        name="Dairy"
        onNameChange={vi.fn()}
        onSave={onSave}
        isDirty={true}
      />
    )

    const saveButton = screen.getByRole('button', { name: /save/i })
    await user.click(saveButton)

    expect(onSave).toHaveBeenCalled()
  })

  it('disables save button when pending', () => {
    render(
      <TagNameForm
        name="Dairy"
        onNameChange={vi.fn()}
        onSave={vi.fn()}
        isDirty={true}
        isPending={true}
      />
    )

    const saveButton = screen.getByRole('button', { name: /save/i })
    expect(saveButton).toBeDisabled()
  })
})
```

**Step 2: Run test to verify it fails**

```bash
pnpm test src/components/TagNameForm.test.tsx
```

Expected: FAIL - module not found

**Step 3: Write minimal implementation**

Create `src/components/TagNameForm.tsx`:

```tsx
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'

interface TagNameFormProps {
  name: string
  onNameChange: (name: string) => void
  onSave: () => void
  isDirty: boolean
  isPending?: boolean
}

export function TagNameForm({
  name,
  onNameChange,
  onSave,
  isDirty,
  isPending,
}: TagNameFormProps) {
  return (
    <form
      className="space-y-4 max-w-md"
      onSubmit={(e) => {
        e.preventDefault()
        onSave()
      }}
    >
      <div className="space-y-2">
        <Label htmlFor="tag-name">Name</Label>
        <Input
          id="tag-name"
          value={name}
          onChange={(e) => onNameChange(e.target.value)}
        />
      </div>
      <Button type="submit" disabled={!isDirty || isPending}>
        Save
      </Button>
    </form>
  )
}
```

**Step 4: Run test to verify it passes**

```bash
pnpm test src/components/TagNameForm.test.tsx
```

Expected: PASS (all 6 tests)

**Step 5: Commit**

```bash
git add src/components/TagNameForm.tsx src/components/TagNameForm.test.tsx
git commit -m "feat(tags): add TagNameForm presentational component"
```

---

## Task 3: Create tag detail layout (parent route)

**Files:**
- Create: `src/routes/settings/tags/$id.tsx`
- Reference: `src/routes/settings/vendors/$id.tsx` (mirror this pattern)

**Step 1: Write the implementation**

Create `src/routes/settings/tags/$id.tsx`:

```tsx
import {
  createFileRoute,
  Link,
  Outlet,
  useNavigate,
  useRouter,
} from '@tanstack/react-router'
import { ArrowLeft, ListTodo, Settings2 } from 'lucide-react'
import { useState } from 'react'
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog'
import { useAppNavigation } from '@/hooks/useAppNavigation'
import { useTagLayout, TagLayoutProvider } from '@/hooks/useTagLayout'
import { useTags } from '@/hooks/useTags'

export const Route = createFileRoute('/settings/tags/$id')({
  component: TagDetailLayout,
})

function TagDetailLayoutInner() {
  const { id } = Route.useParams()
  const navigate = useNavigate()
  const router = useRouter()
  const { data: tags = [] } = useTags()
  const tag = tags.find((t) => t.id === id)
  const { isDirty } = useTagLayout()
  const { goBack } = useAppNavigation('/settings/tags')

  const [showDiscardDialog, setShowDiscardDialog] = useState(false)
  const [pendingNavigation, setPendingNavigation] = useState<string | null>(
    null,
  )

  const handleTabClick = (
    e: React.MouseEvent<HTMLAnchorElement>,
    path: string,
  ) => {
    if (isDirty && router.state.location.pathname !== path) {
      e.preventDefault()
      setPendingNavigation(path)
      setShowDiscardDialog(true)
    }
  }

  const handleBackClick = () => {
    if (isDirty) {
      setPendingNavigation('BACK')
      setShowDiscardDialog(true)
    } else {
      goBack()
    }
  }

  const confirmDiscard = () => {
    if (pendingNavigation) {
      setShowDiscardDialog(false)
      if (pendingNavigation === 'BACK') {
        goBack()
      } else {
        navigate({ to: pendingNavigation })
      }
      setPendingNavigation(null)
    }
  }

  const cancelDiscard = () => {
    setShowDiscardDialog(false)
    setPendingNavigation(null)
  }

  if (!tag) {
    return <div className="p-4">Tag not found</div>
  }

  return (
    <>
      <div className="min-h-screen">
        {/* Fixed Top Bar */}
        <div
          className={`px-3 flex items-center gap-2
          fixed top-0 left-0 right-0 z-50
          bg-background-elevated
          border-b-2 border-accessory-default`}
        >
          <button
            type="button"
            onClick={handleBackClick}
            className="px-3 py-4 hover:bg-background-surface transition-colors"
            aria-label="Go back"
          >
            <ArrowLeft className="h-4 w-4" />
          </button>
          <h1 className="text-md font-regular truncate flex-1">
            {tag.name}
          </h1>

          {/* Tabs */}
          <div className="flex items-center">
            <Link
              to="/settings/tags/$id"
              params={{ id }}
              activeOptions={{ exact: true }}
              className="px-3 py-4 -mb-[2px] border-b-2 border-accessory-default hover:bg-background-surface transition-colors"
              activeProps={{ className: 'border-foreground-muted' }}
              onClick={(e) => handleTabClick(e, `/settings/tags/${id}`)}
            >
              <Settings2 className="h-4 w-4" />
            </Link>
            <Link
              to="/settings/tags/$id/items"
              params={{ id }}
              className="px-3 py-4 -mb-[2px] border-b-2 border-accessory-default hover:bg-background-surface transition-colors"
              activeProps={{ className: 'border-foreground-muted' }}
              onClick={(e) =>
                handleTabClick(e, `/settings/tags/${id}/items`)
              }
            >
              <ListTodo className="h-4 w-4" />
            </Link>
          </div>
        </div>

        {/* Main Content with padding to clear fixed bar */}
        <div className="pt-16 p-4">
          <Outlet />
        </div>
      </div>

      {/* Discard Confirmation Dialog */}
      <AlertDialog open={showDiscardDialog} onOpenChange={setShowDiscardDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Unsaved changes</AlertDialogTitle>
            <AlertDialogDescription>
              You have unsaved changes. Discard changes?
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel onClick={cancelDiscard}>
              Cancel
            </AlertDialogCancel>
            <AlertDialogAction onClick={confirmDiscard}>
              Discard
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  )
}

function TagDetailLayout() {
  return (
    <TagLayoutProvider>
      <TagDetailLayoutInner />
    </TagLayoutProvider>
  )
}
```

**Step 2: Verify it compiles**

```bash
pnpm build
```

Expected: Build succeeds

**Step 3: Commit**

```bash
git add src/routes/settings/tags/\$id.tsx
git commit -m "feat(tags): add tag detail layout with tabs and navigation guard"
```

---

## Task 4: Create Info tab

**Files:**
- Create: `src/routes/settings/tags/$id/index.tsx`
- Reference: `src/routes/settings/vendors/$id/index.tsx` (mirror this pattern)

**Step 1: Write the implementation**

Create `src/routes/settings/tags/$id/index.tsx`:

```tsx
import { createFileRoute } from '@tanstack/react-router'
import { useEffect, useState } from 'react'
import { TagNameForm } from '@/components/TagNameForm'
import { useAppNavigation } from '@/hooks/useAppNavigation'
import { useTagLayout } from '@/hooks/useTagLayout'
import { useTags, useUpdateTag } from '@/hooks/useTags'

export const Route = createFileRoute('/settings/tags/$id/')({
  component: TagInfoTab,
})

function TagInfoTab() {
  const { id } = Route.useParams()
  const { data: tags = [] } = useTags()
  const tag = tags.find((t) => t.id === id)
  const updateTag = useUpdateTag()
  const { registerDirtyState } = useTagLayout()
  const { goBack } = useAppNavigation()

  const [name, setName] = useState('')
  const [savedAt, setSavedAt] = useState(0)

  // Sync name when tag loads or after save
  // biome-ignore lint/correctness/useExhaustiveDependencies: intentionally sync only on id change or after save
  useEffect(() => {
    if (tag) {
      setName(tag.name)
    }
  }, [tag?.id, savedAt])

  const isDirty = tag ? name !== tag.name : false

  useEffect(() => {
    registerDirtyState(isDirty)
  }, [isDirty, registerDirtyState])

  const handleSave = () => {
    if (!tag || !isDirty) return
    updateTag.mutate(
      { id, updates: { name } },
      {
        onSuccess: () => {
          setSavedAt((n) => n + 1)
          goBack()
        },
      },
    )
  }

  if (!tag) return null

  return (
    <TagNameForm
      name={name}
      onNameChange={setName}
      onSave={handleSave}
      isDirty={isDirty}
      isPending={updateTag.isPending}
    />
  )
}
```

**Step 2: Verify it compiles**

```bash
pnpm build
```

Expected: Build succeeds

**Step 3: Commit**

```bash
git add src/routes/settings/tags/\$id/index.tsx
git commit -m "feat(tags): add Info tab for editing tag name"
```

---

## Task 5: Create Items tab

**Files:**
- Create: `src/routes/settings/tags/$id/items.tsx`
- Reference: `src/routes/settings/vendors/$id/items.tsx` (mirror this pattern)

**Step 1: Write the implementation**

Create `src/routes/settings/tags/$id/items.tsx`:

```tsx
import { createFileRoute } from '@tanstack/react-router'
import { Check, Plus, X } from 'lucide-react'
import { useMemo, useState } from 'react'
import { Badge } from '@/components/ui/badge'
import { Button } from '@/components/ui/button'
import { Checkbox } from '@/components/ui/checkbox'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { useCreateItem, useItems, useUpdateItem } from '@/hooks'
import { useTags, useTagTypes } from '@/hooks/useTags'

export const Route = createFileRoute('/settings/tags/$id/items')({
  component: TagItemsTab,
})

function TagItemsTab() {
  const { id: tagId } = Route.useParams()
  const { data: items = [] } = useItems()
  const { data: tags = [] } = useTags()
  const { data: tagTypes = [] } = useTagTypes()
  const updateItem = useUpdateItem()

  const [search, setSearch] = useState('')
  const [savingItemIds, setSavingItemIds] = useState<Set<string>>(new Set())
  const [isCreating, setIsCreating] = useState(false)
  const [newItemName, setNewItemName] = useState('')
  const createItem = useCreateItem()

  const handleCreate = async () => {
    const trimmed = newItemName.trim()
    if (!trimmed) return
    try {
      await createItem.mutateAsync({
        name: trimmed,
        tagIds: [tagId],
        vendorIds: [],
        targetUnit: 'package',
        targetQuantity: 1,
        refillThreshold: 1,
        packedQuantity: 0,
        unpackedQuantity: 0,
        consumeAmount: 1,
      })
      setNewItemName('')
      setIsCreating(false)
    } catch {
      // mutateAsync rejection is handled by TanStack Query; input stays open for retry
    }
  }

  const handleNewItemKeyDown = async (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') await handleCreate()
    if (e.key === 'Escape') {
      setNewItemName('')
      setIsCreating(false)
    }
  }

  const tagMap = useMemo(
    () => Object.fromEntries(tags.map((t) => [t.id, t])),
    [tags],
  )

  const tagTypeMap = useMemo(
    () => Object.fromEntries(tagTypes.map((tt) => [tt.id, tt])),
    [tagTypes],
  )

  const isAssigned = (tagIds: string[] = []) => tagIds.includes(tagId)

  const handleToggle = async (
    itemId: string,
    currentTagIds: string[] = [],
  ) => {
    if (savingItemIds.has(itemId)) return // guard against re-entrancy
    const dbAssigned = currentTagIds.includes(tagId)
    const newTagIds = dbAssigned
      ? currentTagIds.filter((id) => id !== tagId)
      : [...currentTagIds, tagId]

    setSavingItemIds((prev) => new Set(prev).add(itemId))
    try {
      await updateItem.mutateAsync({
        id: itemId,
        updates: { tagIds: newTagIds },
      })
    } finally {
      setSavingItemIds((prev) => {
        const next = new Set(prev)
        next.delete(itemId)
        return next
      })
    }
  }

  const sortedItems = [...items].sort((a, b) =>
    a.name.localeCompare(b.name, undefined, { sensitivity: 'base' }),
  )

  const filteredItems = sortedItems.filter((item) =>
    item.name.toLowerCase().includes(search.toLowerCase()),
  )

  return (
    <div className="space-y-4 max-w-2xl">
      <div className="flex gap-2">
        <Input
          placeholder="Search items..."
          value={search}
          onChange={(e) => setSearch(e.target.value)}
        />
        <Button
          variant="outline"
          aria-label="New item"
          onClick={() => setIsCreating(true)}
          disabled={isCreating}
        >
          <Plus className="h-4 w-4" />
          New
        </Button>
      </div>

      {isCreating && (
        <div className="flex gap-2">
          <Input
            autoFocus
            placeholder="Item name..."
            value={newItemName}
            onChange={(e) => setNewItemName(e.target.value)}
            onKeyDown={handleNewItemKeyDown}
          />
          <Button
            size="icon"
            aria-label="Add item"
            onClick={handleCreate}
            disabled={!newItemName.trim() || createItem.isPending}
          >
            <Check className="h-4 w-4" />
          </Button>
          <Button
            size="icon"
            variant="outline"
            aria-label="Cancel"
            onClick={() => {
              setNewItemName('')
              setIsCreating(false)
            }}
          >
            <X className="h-4 w-4" />
          </Button>
        </div>
      )}

      {items.length === 0 && !isCreating && (
        <p className="text-sm text-foreground-muted">No items yet.</p>
      )}

      <div className="space-y-2">
        {filteredItems.map((item) => {
          const otherTags = (item.tagIds ?? [])
            .filter((tid) => tid !== tagId)
            .map((tid) => tagMap[tid])
            .filter((t): t is NonNullable<typeof t> => t != null)

          return (
            <div
              key={item.id}
              className="flex items-center gap-3 py-2 px-1 rounded hover:bg-background-surface transition-colors"
            >
              <Checkbox
                id={`item-${item.id}`}
                checked={isAssigned(item.tagIds)}
                onCheckedChange={() => handleToggle(item.id, item.tagIds)}
                disabled={savingItemIds.has(item.id)}
              />
              <Label
                htmlFor={`item-${item.id}`}
                className="flex-1 cursor-pointer font-normal"
              >
                {item.name}
              </Label>
              <div className="flex gap-1 flex-wrap justify-end">
                {otherTags.map((t) => {
                  const tagType = tagTypeMap[t.typeId]
                  return (
                    <Badge
                      key={t.id}
                      variant="neutral-outline"
                      className="text-xs"
                    >
                      {t.name}
                    </Badge>
                  )
                })}
              </div>
            </div>
          )
        })}
      </div>
    </div>
  )
}
```

**Step 2: Verify it compiles**

```bash
pnpm build
```

Expected: Build succeeds

**Step 3: Commit**

```bash
git add src/routes/settings/tags/\$id/items.tsx
git commit -m "feat(tags): add Items tab for managing tag assignments"
```

---

## Task 6: Update tags list to navigate instead of showing dialog

**Files:**
- Modify: `src/routes/settings/tags.tsx`

**Step 1: Read current implementation**

```bash
cat src/routes/settings/tags.tsx | head -100
```

Review how TagBadge is currently used and how TagDetailDialog works.

**Step 2: Update tags.tsx to navigate instead of showing dialog**

Remove these imports:
- `TagDetailDialog`
- `editTag`, `setEditTag` state
- `editTagName`, `setEditTagName` state
- `handleEditTag` function
- `handleDeleteTag` function

Update TagBadge onClick to navigate:

```tsx
// Replace this:
<TagBadge
  key={tag.id}
  tag={tag}
  tagType={tagType}
  onClick={() => {
    setEditTag(tag)
    setEditTagName(tag.name)
  }}
/>

// With this (using Link wrapper):
import { Link } from '@tanstack/react-router'

<Link
  key={tag.id}
  to="/settings/tags/$id"
  params={{ id: tag.id }}
  className="inline-block"
>
  <TagBadge tag={tag} tagType={tagType} />
</Link>
```

Remove TagDetailDialog JSX:

```tsx
{/* Remove this entire block: */}
{editTag && (
  <TagDetailDialog
    tag={editTag}
    tagName={editTagName}
    onTagNameChange={setEditTagName}
    onSave={handleEditTag}
    onDelete={handleDeleteTag}
    onClose={() => setEditTag(null)}
  />
)}
```

**Step 3: Verify it compiles**

```bash
pnpm build
```

Expected: Build succeeds

**Step 4: Test manually**

```bash
pnpm dev
```

Navigate to /settings/tags and click a tag badge. Should navigate to tag detail page.

**Step 5: Commit**

```bash
git add src/routes/settings/tags.tsx
git commit -m "feat(tags): navigate to detail page instead of showing edit dialog"
```

---

## Task 7: Write integration tests

**Files:**
- Create: `src/routes/settings/tags/$id.test.tsx`
- Reference: `src/routes/settings/vendors/$id.test.tsx` (mirror test patterns)

**Step 1: Write the test file**

Create `src/routes/settings/tags/$id.test.tsx`:

```tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { RouterProvider, createMemoryHistory, createRouter } from '@tanstack/react-router'
import { render, screen, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { beforeEach, describe, expect, it, vi } from 'vitest'
import { db } from '@/db'
import { routeTree } from '@/routeTree.gen'
import type { Item, Tag, TagType } from '@/types'

// Mock useAppNavigation
vi.mock('@/hooks/useAppNavigation', () => ({
  useAppNavigation: (fallback?: string) => ({
    goBack: vi.fn(() => {
      // Simple mock implementation
    }),
  }),
}))

describe('Tag Detail Page', () => {
  let queryClient: QueryClient
  let testTag: Tag
  let testTagType: TagType
  let testItem1: Item
  let testItem2: Item

  beforeEach(async () => {
    await db.delete()
    await db.open()

    queryClient = new QueryClient({
      defaultOptions: {
        queries: { retry: false },
        mutations: { retry: false },
      },
    })

    // Create test tag type
    testTagType = await db.tagTypes.add({
      name: 'Category',
      color: 'blue' as any,
    }).then(id => db.tagTypes.get(id)).then(tt => tt!)

    // Create test tag
    testTag = await db.tags.add({
      name: 'Dairy',
      typeId: testTagType.id,
    }).then(id => db.tags.get(id)).then(t => t!)

    // Create test items
    testItem1 = await db.items.add({
      name: 'Milk',
      tagIds: [testTag.id],
      vendorIds: [],
      targetUnit: 'package',
      targetQuantity: 2,
      refillThreshold: 1,
      packedQuantity: 0,
      unpackedQuantity: 0,
      consumeAmount: 1,
      createdAt: new Date(),
      updatedAt: new Date(),
    }).then(id => db.items.get(id)).then(i => i!)

    testItem2 = await db.items.add({
      name: 'Cheese',
      tagIds: [],
      vendorIds: [],
      targetUnit: 'package',
      targetQuantity: 1,
      refillThreshold: 1,
      packedQuantity: 0,
      unpackedQuantity: 0,
      consumeAmount: 1,
      createdAt: new Date(),
      updatedAt: new Date(),
    }).then(id => db.items.get(id)).then(i => i!)
  })

  function renderTagDetail(tagId: string) {
    const history = createMemoryHistory({
      initialEntries: [`/settings/tags/${tagId}`],
    })

    const router = createRouter({
      routeTree,
      history,
      context: { queryClient },
    })

    return render(
      <QueryClientProvider client={queryClient}>
        <RouterProvider router={router} />
      </QueryClientProvider>
    )
  }

  it('user can view tag detail page and see tag name', async () => {
    renderTagDetail(testTag.id)

    await waitFor(() => {
      expect(screen.getByText('Dairy')).toBeInTheDocument()
    })
  })

  it('user can edit tag name and save changes', async () => {
    const user = userEvent.setup()
    renderTagDetail(testTag.id)

    // Wait for form to load
    await waitFor(() => {
      expect(screen.getByLabelText('Name')).toBeInTheDocument()
    })

    const input = screen.getByLabelText('Name')
    const saveButton = screen.getByRole('button', { name: /save/i })

    // Initially save button is disabled
    expect(saveButton).toBeDisabled()

    // Edit name
    await user.clear(input)
    await user.type(input, 'Meat')

    // Save button becomes enabled
    expect(saveButton).not.toBeDisabled()

    // Save changes
    await user.click(saveButton)

    // Verify tag was updated in database
    await waitFor(async () => {
      const updatedTag = await db.tags.get(testTag.id)
      expect(updatedTag?.name).toBe('Meat')
    })
  })

  it('user can navigate between Info and Items tabs', async () => {
    const user = userEvent.setup()
    renderTagDetail(testTag.id)

    // Wait for page to load
    await waitFor(() => {
      expect(screen.getByText('Dairy')).toBeInTheDocument()
    })

    // Find Items tab button (ListTodo icon)
    const itemsTab = screen.getAllByRole('link').find(link =>
      link.getAttribute('href')?.includes('/items')
    )
    expect(itemsTab).toBeInTheDocument()

    // Click Items tab
    await user.click(itemsTab!)

    // Should see items list
    await waitFor(() => {
      expect(screen.getByPlaceholderText('Search items...')).toBeInTheDocument()
    })
  })

  it('user sees discard dialog when navigating away with unsaved changes', async () => {
    const user = userEvent.setup()
    renderTagDetail(testTag.id)

    // Wait for form to load
    await waitFor(() => {
      expect(screen.getByLabelText('Name')).toBeInTheDocument()
    })

    // Make changes
    const input = screen.getByLabelText('Name')
    await user.clear(input)
    await user.type(input, 'Modified')

    // Try to switch tabs
    const itemsTab = screen.getAllByRole('link').find(link =>
      link.getAttribute('href')?.includes('/items')
    )
    await user.click(itemsTab!)

    // Should see discard dialog
    await waitFor(() => {
      expect(screen.getByText('Unsaved changes')).toBeInTheDocument()
      expect(screen.getByText(/discard changes/i)).toBeInTheDocument()
    })
  })

  it('user can cancel discard and keep changes', async () => {
    const user = userEvent.setup()
    renderTagDetail(testTag.id)

    await waitFor(() => {
      expect(screen.getByLabelText('Name')).toBeInTheDocument()
    })

    const input = screen.getByLabelText('Name')
    await user.clear(input)
    await user.type(input, 'Modified')

    const itemsTab = screen.getAllByRole('link').find(link =>
      link.getAttribute('href')?.includes('/items')
    )
    await user.click(itemsTab!)

    await waitFor(() => {
      expect(screen.getByText('Unsaved changes')).toBeInTheDocument()
    })

    // Click Cancel
    const cancelButton = screen.getByRole('button', { name: /cancel/i })
    await user.click(cancelButton)

    // Should still be on Info tab with changes preserved
    await waitFor(() => {
      expect(screen.getByLabelText('Name')).toHaveValue('Modified')
    })
  })

  it('user can confirm discard and lose changes', async () => {
    const user = userEvent.setup()
    renderTagDetail(testTag.id)

    await waitFor(() => {
      expect(screen.getByLabelText('Name')).toBeInTheDocument()
    })

    const input = screen.getByLabelText('Name')
    await user.clear(input)
    await user.type(input, 'Modified')

    const itemsTab = screen.getAllByRole('link').find(link =>
      link.getAttribute('href')?.includes('/items')
    )
    await user.click(itemsTab!)

    await waitFor(() => {
      expect(screen.getByText('Unsaved changes')).toBeInTheDocument()
    })

    // Click Discard
    const discardButton = screen.getByRole('button', { name: /discard/i })
    await user.click(discardButton)

    // Should navigate to Items tab
    await waitFor(() => {
      expect(screen.getByPlaceholderText('Search items...')).toBeInTheDocument()
    })
  })

  it('user can assign/unassign items to tag via checkboxes', async () => {
    const user = userEvent.setup()
    renderTagDetail(testTag.id)

    // Navigate to Items tab
    await waitFor(() => {
      expect(screen.getByText('Dairy')).toBeInTheDocument()
    })

    const itemsTab = screen.getAllByRole('link').find(link =>
      link.getAttribute('href')?.includes('/items')
    )
    await user.click(itemsTab!)

    await waitFor(() => {
      expect(screen.getByText('Milk')).toBeInTheDocument()
      expect(screen.getByText('Cheese')).toBeInTheDocument()
    })

    // Milk should be checked (already assigned)
    const milkCheckbox = screen.getByLabelText('Milk')
    expect(milkCheckbox).toBeChecked()

    // Cheese should be unchecked
    const cheeseCheckbox = screen.getByLabelText('Cheese')
    expect(cheeseCheckbox).not.toBeChecked()

    // Assign tag to Cheese
    await user.click(cheeseCheckbox)

    // Verify in database
    await waitFor(async () => {
      const updatedItem = await db.items.get(testItem2.id)
      expect(updatedItem?.tagIds).toContain(testTag.id)
    })

    // Unassign tag from Milk
    await user.click(milkCheckbox)

    await waitFor(async () => {
      const updatedItem = await db.items.get(testItem1.id)
      expect(updatedItem?.tagIds).not.toContain(testTag.id)
    })
  })

  it('user can search items in Items tab', async () => {
    const user = userEvent.setup()
    renderTagDetail(testTag.id)

    // Navigate to Items tab
    await waitFor(() => {
      expect(screen.getByText('Dairy')).toBeInTheDocument()
    })

    const itemsTab = screen.getAllByRole('link').find(link =>
      link.getAttribute('href')?.includes('/items')
    )
    await user.click(itemsTab!)

    await waitFor(() => {
      expect(screen.getByPlaceholderText('Search items...')).toBeInTheDocument()
    })

    // Both items should be visible
    expect(screen.getByText('Milk')).toBeInTheDocument()
    expect(screen.getByText('Cheese')).toBeInTheDocument()

    // Search for Milk
    const searchInput = screen.getByPlaceholderText('Search items...')
    await user.type(searchInput, 'milk')

    // Only Milk should be visible
    expect(screen.getByText('Milk')).toBeInTheDocument()
    expect(screen.queryByText('Cheese')).not.toBeInTheDocument()
  })

  it('user can create new item with tag pre-assigned', async () => {
    const user = userEvent.setup()
    renderTagDetail(testTag.id)

    // Navigate to Items tab
    await waitFor(() => {
      expect(screen.getByText('Dairy')).toBeInTheDocument()
    })

    const itemsTab = screen.getAllByRole('link').find(link =>
      link.getAttribute('href')?.includes('/items')
    )
    await user.click(itemsTab!)

    await waitFor(() => {
      expect(screen.getByPlaceholderText('Search items...')).toBeInTheDocument()
    })

    // Click New button
    const newButton = screen.getByRole('button', { name: /new item/i })
    await user.click(newButton)

    // Should show input
    const nameInput = screen.getByPlaceholderText('Item name...')
    expect(nameInput).toBeInTheDocument()

    // Type name and submit
    await user.type(nameInput, 'Yogurt')
    const addButton = screen.getByRole('button', { name: /add item/i })
    await user.click(addButton)

    // Verify item was created with tag assigned
    await waitFor(async () => {
      const items = await db.items.toArray()
      const yogurt = items.find(i => i.name === 'Yogurt')
      expect(yogurt).toBeDefined()
      expect(yogurt?.tagIds).toContain(testTag.id)
    })

    // Should see new item in list
    expect(screen.getByText('Yogurt')).toBeInTheDocument()
  })

  it('shows "Tag not found" for invalid tag ID', async () => {
    renderTagDetail('invalid-id')

    await waitFor(() => {
      expect(screen.getByText('Tag not found')).toBeInTheDocument()
    })
  })

  it('shows "No items yet" when there are no items', async () => {
    const user = userEvent.setup()

    // Delete all items
    await db.items.clear()

    renderTagDetail(testTag.id)

    // Navigate to Items tab
    await waitFor(() => {
      expect(screen.getByText('Dairy')).toBeInTheDocument()
    })

    const itemsTab = screen.getAllByRole('link').find(link =>
      link.getAttribute('href')?.includes('/items')
    )
    await user.click(itemsTab!)

    await waitFor(() => {
      expect(screen.getByText('No items yet.')).toBeInTheDocument()
    })
  })
})
```

**Step 2: Run tests to verify they pass**

```bash
pnpm test src/routes/settings/tags/\$id.test.tsx
```

Expected: PASS (all tests)

**Step 3: Commit**

```bash
git add src/routes/settings/tags/\$id.test.tsx
git commit -m "test(tags): add integration tests for tag detail page"
```

---

## Task 8: Update CLAUDE.md documentation

**Files:**
- Modify: `CLAUDE.md`

**Step 1: Add tag detail page documentation**

Add a new section after "Vendor Management":

```markdown
### Tag Management

Tag detail page at `/settings/tags/$id` with Info and Items tabs, mirroring vendor detail page pattern.

**Tag detail page**: `src/routes/settings/tags/$id.tsx` — Tabbed layout (Info + Items). Info tab: edit tag name with Save button. Items tab: searchable checklist of all items showing their current tag assignments; saves immediately when a checkbox is clicked (no staged state, no Save button), same pattern as vendor Items tab. `+ New` button opens an inline input to create a new item immediately assigned to this tag, saved directly to DB.

**Dirty state**: `src/hooks/useTagLayout.tsx` — same pattern as `useVendorLayout`. Navigation guard on parent layout applies only to the Info tab (tag name editing); the Items tab has no unsaved state.

**Navigation:**

Back button and post-action navigation use smart history tracking (same pattern as vendor detail pages). After successful save, automatically navigates back to previous page. Uses `useAppNavigation()` hook.

**Entry point:** Click tag badge on tags list page (`/settings/tags`) to navigate to tag detail page.

**Files:**
- `src/routes/settings/tags/$id.tsx` - Parent layout with tabs and navigation guard
- `src/routes/settings/tags/$id/index.tsx` - Info tab
- `src/routes/settings/tags/$id/items.tsx` - Items tab
- `src/hooks/useTagLayout.tsx` - Dirty state provider
- `src/components/TagNameForm.tsx` - Presentational form component
```

**Step 2: Commit**

```bash
git add CLAUDE.md
git commit -m "docs(tags): add tag detail page to CLAUDE.md"
```

---

## Final Verification

**Step 1: Run all tests**

```bash
pnpm test
```

Expected: All tests pass

**Step 2: Build project**

```bash
pnpm build
```

Expected: Build succeeds

**Step 3: Manual testing**

```bash
pnpm dev
```

Test flow:
1. Navigate to /settings/tags
2. Click a tag badge → should navigate to /settings/tags/$id
3. Edit tag name → Save button enables
4. Save → should navigate back to tags list
5. Return to tag detail → click Items tab
6. Search for items, assign/unassign tags via checkboxes
7. Click + New → create new item with tag pre-assigned
8. Verify navigation guard works (edit name, try to switch tabs without saving)

---

## Summary

This implementation adds a tag detail page that mirrors the vendor detail page pattern:

- **Hook**: `useTagLayout` for dirty state tracking
- **Component**: `TagNameForm` for presentational form
- **Routes**: Parent layout + Info tab + Items tab
- **Integration**: Updated tags list to navigate instead of showing dialog
- **Tests**: Comprehensive integration tests covering all user scenarios
- **Docs**: Updated CLAUDE.md

All components follow existing patterns from the vendor implementation, ensuring consistency across the codebase.
